package kotlin

import (
	"fmt"
	"github.com/Workiva/frugal/compiler/generator"
	"github.com/Workiva/frugal/compiler/globals"
	"github.com/Workiva/frugal/compiler/parser"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

const (
	lang                        = "kotlin"
	defaultOutputDir            = "gen-kotlin"
	generatedAnnotations        = "generated_annotations"
	useVendorOption             = "use_vendor"
	suppressDeprecatedLogging   = "suppress_deprecated_logging"
	tab                         = "\t"
	tabtab                      = tab + tab
	tabtabtab                   = tab + tab + tab
	tabtabtabtab                = tab + tab + tab + tab
	tabtabtabtabtab             = tab + tab + tab + tab + tab
	tabtabtabtabtabtab          = tab + tab + tab + tab + tab + tab
	tabtabtabtabtabtabtab       = tab + tab + tab + tab + tab + tab + tab
	tabtabtabtabtabtabtabtab    = tab + tab + tab + tab + tab + tab + tab + tab
	tabtabtabtabtabtabtabtabtab = tab + tab + tab + tab + tab + tab + tab + tab + tab
)

type Generator struct {
	*generator.BaseGenerator
	time      time.Time
	outputDir string
}

func (g *Generator) GenerateDependencies(dir string) error {
	return nil
}

func (g *Generator) GenerateFile(name, outputDir string, fileType generator.FileType) (*os.File, error) {
	switch fileType {
	case generator.PublishFile:
		return g.CreateFile(strings.Title(name)+"Publisher", outputDir, lang, false)
	case generator.SubscribeFile:
		return g.CreateFile(strings.Title(name)+"Subscriber", outputDir, lang, false)
	case generator.CombinedServiceFile:
		return g.CreateFile("F"+name, outputDir, lang, false)
	case generator.ObjectFile:
		return g.CreateFile(name, outputDir, lang, false)
	default:
		return nil, fmt.Errorf("Bad file type for Java generator: %s", fileType)
	}
}

func (g *Generator) GenerateDocStringComment(file *os.File) error {
	comment := fmt.Sprintf(
		"/**\n"+
			" * Autogenerated by Frugal Compiler (%s)\n"+
			" * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING\n"+
			" *\n"+
			" * @generated\n"+
			" */",
		globals.Version)

	_, err := file.WriteString(comment)
	return err
}

func (g *Generator) GenerateConstants(f *os.File, name string) error {
	return nil
}

func (g *Generator) GetOutputDir(dir string) string {
	if namespace := g.Frugal.Namespace(lang); namespace != nil {
		path := generator.GetPackageComponents(namespace.Value)
		dir = filepath.Join(append([]string{dir}, path...)...)
	}
	return dir}

func (g *Generator) DefaultOutputDir() string {
	return defaultOutputDir
}

func (g *Generator) PostProcess(*os.File) error {
	return nil
}

func (g *Generator) GenerateConstantsContents(constants []*parser.Constant) error {
	if len(constants) == 0 {
		return nil
	}

	contents := ""

	if g.includeGeneratedAnnotation() {
		contents += g.generatedAnnotation("")
	}
	contents += fmt.Sprintf("class %sConstants {\n", g.Frugal.Name)

	//for _, constant := range constants {
		//val := g.generateConstantValueWrapper(constant.Name, constant.Type, constant.Value, true, true, tab)
		//contents += fmt.Sprintf("%s\n", val)
	//}

	contents += "}\n"

	file, err := g.GenerateFile(fmt.Sprintf("%sConstants", g.Frugal.Name), g.outputDir, generator.ObjectFile)
	defer file.Close()
	if err != nil {
		return err
	}

	if err = g.initStructFile(file); err != nil {
		return err
	}
	_, err = file.WriteString(contents)

	return err
}

func (g *Generator) GenerateTypeDef(*parser.TypeDef) error {
	// todo can we use kotlin alias or something???
	return nil
}

func (g *Generator) GenerateEnum(enum *parser.Enum) error {
	contents := ""
	contents += fmt.Sprintf("enum class %s private constructor(private val value: Int) : org.apache.thrift.TEnum {\n", enum.Name)
	contents += "}\n"

	file, err := g.GenerateFile(enum.Name, g.outputDir, generator.ObjectFile)
	defer file.Close()
	if err != nil {
		return err
	}

	if err = g.GenerateDocStringComment(file); err != nil {
		return err
	}
	if _, err = file.WriteString("\n"); err != nil {
		return err
	}
	if err = g.generatePackage(file); err != nil {
		return err
	}
	if _, err = file.WriteString("\n\n"); err != nil {
		return err
	}

	_, err = file.WriteString(contents)

	return err
}

func (g *Generator) GenerateStruct(*parser.Struct) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateUnion(*parser.Struct) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateException(*parser.Struct) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateServicePackage(*os.File, *parser.Service) error {
	// TODO implement me
	return nil	
}

func (g *Generator) GenerateServiceImports(*os.File, *parser.Service) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateService(*os.File, *parser.Service) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateScopePackage(*os.File, *parser.Scope) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateScopeImports(*os.File, *parser.Scope) error {
	// TODO implement me
	return nil
}

func (g *Generator) GeneratePublisher(*os.File, *parser.Scope) error {
	// TODO implement me
	return nil
}

func (g *Generator) GenerateSubscriber(*os.File, *parser.Scope) error {
	// TODO implement me
	return nil
}

func NewGenerator(options map[string]string) generator.LanguageGenerator {
	return &Generator{
		&generator.BaseGenerator{Options: options},
		globals.Now,
		"",
	}
}

// ADTs would be really nice
type IsSetType int64

const (
	IsSetNone IsSetType = iota
	IsSetBitfield
	IsSetBitSet
)

func (g *Generator) initStructFile(file *os.File) error {
	if err := g.GenerateDocStringComment(file); err != nil {
		return err
	}
	if _, err := file.WriteString("\n"); err != nil {
		return err
	}
	//if err := g.generatePackage(file); err != nil {
	//	return err
	//}

	if _, err := file.WriteString("\n\n"); err != nil {
		return err
	}

	//return g.GenerateStructImports(file)
	return nil
}


// Suppress deprecated API usage warning logging
func (g *Generator) suppressDeprecatedLogging() bool {
	_, ok := g.Options[suppressDeprecatedLogging]
	return ok
}

func (g *Generator) SetupGenerator(outputDir string) error {
	g.outputDir = outputDir
	return nil
}

func (g *Generator) TeardownGenerator() error {
	return nil
}

func (g *Generator) isKotlinPrimitive(t *parser.Type) bool {
	if g.generateBoxedPrimitives() {
		// If boxing primitives, nothing is a primitive
		return false
	}

	return g.canBeKotlinPrimitive(t)
}

// quote creates a Kotlin string literal for a string.
func (g *Generator) quote(s string) string {
	// For now, just use Go quoting rules.
	return strconv.Quote(s)
}

func (g *Generator) canBeKotlinPrimitive(t *parser.Type) bool {
	underlyingType := g.Frugal.UnderlyingType(t)
	switch underlyingType.Name {
	case "bool", "byte", "i8", "i16", "i32", "i64", "double":
		return true
	default:
		return false
	}
}

func (g *Generator) generateBoxedPrimitives() bool {
	_, ok := g.Options["boxed_primitives"]
	return ok
}

func (g *Generator) includeGeneratedAnnotation() bool {
	return g.Options[generatedAnnotations] != "" && g.Options[generatedAnnotations] != "suppress"
}

func (g *Generator) generatedAnnotation(indent string) string {
	anno := indent + fmt.Sprintf("@Generated(value = \"Autogenerated by Frugal Compiler (%s)\"", globals.Version)
	if g.Options[generatedAnnotations] != "undated" {
		anno += fmt.Sprintf(", "+"date = \"%s\"", g.time.Format("2006-1-2"))
	}
	anno += ")\n"
	return anno
}

func (g *Generator) generatePackage(file *os.File) error {
	namespace := g.Frugal.Namespace(lang)
	if namespace == nil {
		return nil
	}
	_, err := file.WriteString(fmt.Sprintf("package %s;", namespace.Value))
	return err
}

func (g *Generator) generateAsync() bool {
	_, ok := g.Options["async"]
	return ok
}

func (g *Generator) UseVendor() bool {
	_, ok := g.Options[useVendorOption]
	return ok
}
